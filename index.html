<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reframed</title>
    <script>
        (function(d) {
          var config = {
            kitId: 'vub7iix',
            scriptTimeout: 3000,
            async: true
          },
          h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
        })(document);
      </script>
      <link rel="apple-touch-icon" sizes="57x57" href="favicon/apple-icon-57x57.png">
      <link rel="apple-touch-icon" sizes="60x60" href="favicon/apple-icon-60x60.png">
      <link rel="apple-touch-icon" sizes="72x72" href="favicon/apple-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="76x76" href="favicon/apple-icon-76x76.png">
      <link rel="apple-touch-icon" sizes="114x114" href="favicon/apple-icon-114x114.png">
      <link rel="apple-touch-icon" sizes="120x120" href="favicon/apple-icon-120x120.png">
      <link rel="apple-touch-icon" sizes="144x144" href="favicon/apple-icon-144x144.png">
      <link rel="apple-touch-icon" sizes="152x152" href="favicon/apple-icon-152x152.png">
      <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-icon-180x180.png">
      <link rel="icon" type="image/png" sizes="192x192"  href="favicon/android-icon-192x192.png">
      <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="96x96" href="favicon/favicon-96x96.png">
      <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
      <link rel="manifest" href="favicon/manifest.json">
      <meta name="msapplication-TileColor" content="#ffffff">
      <meta name="msapplication-TileImage" content="favicon/ms-icon-144x144.png">
      <meta name="theme-color" content="#ffffff">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            cursor: none;
        }
        canvas { 
            display: block; 
        }

        /* ğŸ’¡ [ì¶”ê°€] í™”ë©´ ì „í™˜ìš© ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼ */
        #transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* í°ìƒ‰ ë°°ê²½ */
            z-index: 10000; /* ê°€ì¥ ìœ„ì— ë°°ì¹˜ */
            opacity: 1; /* ê¸°ë³¸ê°’: ë¶ˆíˆ¬ëª… (í™”ë©´ ê°€ë¦¼) */
            pointer-events: none; /* í´ë¦­ í†µê³¼ ë°©ì§€ (ì• ë‹ˆë©”ì´ì…˜ ì¤‘ ì¡°ì‘ ë°©ì§€) */
            transition: opacity 0.6s ease-in-out; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼ */
        }
        
        /* ë¡œë”© ì™„ë£Œ ì‹œ ì ìš©í•  í´ë˜ìŠ¤ */
        #transition-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .custom-cursor {
            width: 15px; 
            height: 15px;
            border-radius: 50%;
            background-color: #ffffff; 
            position: fixed; 
            pointer-events: none; 
            z-index: 9999; 
            transform: translate(-50%, -50%); 
            transition: transform 0.1s ease-out; 
            mix-blend-mode: difference; 
            opacity: 1; 
            will-change: transform; 
        }
        
        .hamburger-icon {
            width: 50px; 
            height: 50px;
            background-color: #000000;
            border-radius: 50%; 
            cursor: pointer;
            z-index: 10; 
            flex-shrink: 0; 
            position: absolute; 
            left: 0;
            transition: opacity 0.3s ease; 
            display: flex; 
            justify-content: center;
            align-items: center;
        }
        .hamburger-icon:hover {
            transform: scale(1.05);
        }
        .hamburger-icon img {
            width: 50%; 
            height: 50%;
        }

        .menu-container {
            position: fixed;
            top: 20px;
            left: 50%;
            width: 50px; 
            height: 50px; 
            background-color: #000000;
            border-radius: 30px;
            z-index: 900;
            transform: translateX(-50%);
            transition: width 0.5s ease-in-out, border-radius 0.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: flex-start; 
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .menu-links {
            display: flex;
            gap: 40px;
            opacity: 0;
            padding: 0 0px 0 40px; 
            transition: opacity 0.3s 0.3s; 
        }
        
        .menu-link {
            text-decoration: none;
            color: #f1e4ca;
            font-size: 1rem;
            white-space: nowrap;
            font-family: neue-haas-grotesk-display, sans-serif;
            font-weight: 500;
            font-style: normal;
        }

        .menu-close {
            position: absolute;
            right: 0;
            width: 50px; 
            height: 50px;
            background: none;
            color: #f1e4ca;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0; 
            transition: opacity 0.3s;
        }

        .menu-container.expanded {
            width: 240px; 
            border-radius: 50px; 
            justify-content: space-between; 
        }
        
        .menu-container.expanded .menu-links {
            opacity: 1;
        }

        .top-text {
            position: absolute;
            bottom: 2%;
            left: 2%;
            transform: translateX(-2%);
            width: 90%; 
            max-width: 660px; 
            color: #ffffff;
            mix-blend-mode: difference;
            font-family: "neue-haas-grotesk-display", sans-serif;
            font-weight: 600;
            font-size: 1rem;
            line-height: 1; 
            text-align: left; 
            z-index: 100; 
            pointer-events: none; 
        }

        .footer {
            position: fixed;
            bottom: 20px;
            right: 2%;
            transform: translateX(2%);
            color: #ffffff;
            mix-blend-mode: difference;
            font-family: "neue-haas-grotesk-display", sans-serif;
            font-weight: 600;
            font-size: 1rem;
            line-height: 1; 
            text-align: left; 
            z-index: 100; 
            pointer-events: none;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="transition-overlay"></div>

    <div class="custom-cursor" id="custom-cursor"></div>
    
    <div class="top-text">
        This archive allows visitors to visually experience the connection between two art forms by discovering the pictorial references hidden within familiar movie moments. The platform features film scenes inspired by classic works of art, illuminating the process by which art influences and is reinterprets creation across the boundaries of time and medium.
    </div>
    
    <div class="footer">
        Reframed (C) 2025. AHYUN All rights reserved.
    </div>

    
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        const customCursor = document.getElementById('custom-cursor');
        // ğŸ’¡ [ì¶”ê°€] ì˜¤ë²„ë ˆì´ ìš”ì†Œ ì„ íƒ
        const transitionOverlay = document.getElementById('transition-overlay');

        // ğŸ’¡ [ì¶”ê°€] í˜ì´ì§€ ë¡œë“œ ì‹œ í˜ì´ë“œ ì¸ (ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€)
        window.addEventListener('load', () => {
            setTimeout(() => {
                transitionOverlay.classList.add('hidden');
            }, 100);
        });

        // ğŸ’¡ [ì¶”ê°€] ë¶€ë“œëŸ¬ìš´ í˜ì´ì§€ ì´ë™ í•¨ìˆ˜
        const smoothNavigate = (url) => {
            // ì˜¤ë²„ë ˆì´ë¥¼ ë‹¤ì‹œ ë³´ì´ê²Œ í•¨ (í™”ë©´ì„ í°ìƒ‰ìœ¼ë¡œ ë®ìŒ)
            transitionOverlay.classList.remove('hidden');
            
            // CSS transition ì‹œê°„(0.8ì´ˆ)ë§Œí¼ ëŒ€ê¸° í›„ ì´ë™
            setTimeout(() => {
                window.location.href = url;
            }, 600);
        };

        // --- 1. ê¸°ë³¸ ì„¤ì • ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); 

        const yawObject = new THREE.Object3D();
        yawObject.position.set(0, 0, 0);
        yawObject.add(camera); 
        scene.add(yawObject);  
        
        camera.position.set(0, 0, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio); 
        document.body.appendChild(renderer.domElement);

        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, { 
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter 
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
        scene.add(cubeCamera); 

        // --- 2. ë¹› ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x0C2836, 1.0); 
        directionalLight.position.set(-0.5, 1, 1.8);
        scene.add(directionalLight);

        // --- ê¸€ë¡œìš° í…ìŠ¤ì²˜ ìƒì„± í•¨ìˆ˜ ---
        function createRectGlowTexture() {
            const size = 400; 
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const glowColor = "rgba(235, 197, 121, 1.0)"; 

            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 55; 
            
            const margin = 50; 
            
            ctx.fillStyle = glowColor; 
            ctx.fillRect(margin, margin, size - margin * 2, size - margin * 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const glowTexture = createRectGlowTexture(); 

        // --- 3. ì´ë¯¸ì§€ íŒ¨ë„ ìƒì„± ---
        const imageUrls = [];
        const totalImageCount = 30; 
        for (let i = 1; i <= totalImageCount; i++) {
            imageUrls.push(`web-source/${i}.jpg`); 
        }

        const textureLoader = new THREE.TextureLoader();

        const sphereRadius = 8; 
        const numLayers = 5; 
        const imagesPerLayer = Math.ceil(totalImageCount / numLayers); 
        const layerSpacingAngle = Math.PI * 0.10;
        
        const phiLayers = [
            Math.PI * 0.5 - layerSpacingAngle * 2,
            Math.PI * 0.5 - layerSpacingAngle * 1,
            Math.PI * 0.5,
            Math.PI * 0.5 + layerSpacingAngle * 1,
            Math.PI * 0.5 + layerSpacingAngle * 2
        ];
        
        const imageMeshes = [];
        const imageUrlsMap = new Map(); 

        const targetPositions = []; 
        let animationProgress = 0; 
        const animationDuration = 200; 
        
        let isOverClickable = false;
        let hoveredMesh = null; 

        imageUrls.forEach((url, index) => {
            textureLoader.load(url, (texture) => {
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false; 

                const aspectRatio = texture.image.width / texture.image.height;
                const maxDimension = 1.8; 
                let planeWidth, planeHeight;

                if (aspectRatio >= 1) { 
                    planeWidth = maxDimension;
                    planeHeight = planeWidth / aspectRatio; 
                } else { 
                    planeHeight = maxDimension;
                    planeWidth = planeHeight * aspectRatio; 
                }

                // ì´ë¯¸ì§€ ë©”ì‰¬
                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: 1 }); 
                const mesh = new THREE.Mesh(geometry, material);
                
                // ê¸€ë¡œìš° íŒ¨ë„
                const glowScale = 1.35; 
                const glowGeometry = new THREE.PlaneGeometry(planeWidth * glowScale, planeHeight * glowScale);
                
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    map: glowTexture, 
                    transparent: true,
                    opacity: 0.9, 
                    side: THREE.DoubleSide,
                    depthWrite: false, 
                    blending: THREE.NormalBlending 
                });
                
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                
                glowMesh.position.z = -0.05; 
                glowMesh.visible = false; 
                
                mesh.add(glowMesh);
                mesh.userData.glow = glowMesh;

                mesh.scale.set(0, 0, 0); 
                
                const fileNameMatch = url.match(/(\d+)\.jpg$/);
                let targetPage;

                if (fileNameMatch && fileNameMatch[1]) {
                    const imageNumber = fileNameMatch[1];
                    targetPage = `${imageNumber}.html`;
                } else {
                    targetPage = `page_default.html`; 
                }

                imageUrlsMap.set(mesh, targetPage); 
                imageMeshes.push(mesh); 

                const layerIndex = Math.floor(index / imagesPerLayer);
                const phi = phiLayers[layerIndex];
                const indexInLayer = index % imagesPerLayer;
                
                let startOffset = 0;
                if (layerIndex % 2 !== 0) { 
                    startOffset = (Math.PI / imagesPerLayer) / 2;
                }
                
                const angleIncrement = (indexInLayer / imagesPerLayer) * Math.PI;
                const theta_final_corrected = angleIncrement + startOffset + (Math.PI / 1.8); 

                const finalPosition = new THREE.Vector3().setFromSphericalCoords(sphereRadius, phi, theta_final_corrected);
                targetPositions.push(finalPosition); 
                
                mesh.position.set(0, 0, -5); 
                mesh.renderOrder = 0; 
                scene.add(mesh);
            });
        });

        // --- 4. ì»¤ìŠ¤í…€ 3D ëª¨ë¸ ë¡œë“œ ---
        const gltfLoader = new GLTFLoader();
        let controller; 
        
        gltfLoader.load(
            'model.glb', 
            (gltf) => {
                const model = gltf.scene;

                model.traverse((child) => {
                    if (child.isMesh) {
                        const originalMaterial = child.material;
                        if (originalMaterial.isMeshStandardMaterial) {
                            originalMaterial.envMap = cubeRenderTarget.texture; 
                            originalMaterial.needsUpdate = true;
                            originalMaterial.depthTest = true; 
                            child.renderOrder = 0; 
                        }
                    }
                });

                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const maxAxis = Math.max(size.x, size.y, size.z);
                const targetScale = 2.4 / maxAxis; 
                const scaleMultiplier = 2; 
                const finalScale = targetScale * scaleMultiplier;

                model.scale.set(finalScale, finalScale, finalScale);
                model.position.x -= center.x * finalScale;
                model.position.y -= center.y * finalScale;
                model.position.z -= center.z * finalScale; 

                const container = new THREE.Object3D();
                container.add(model);
                
                container.position.set(0, 0, -5); 

                controller = container; 
                camera.add(controller);
            },
            undefined,
            (error) => console.error('ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error)
        );
        
        // --- 5. ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  ë° Raycaster ---
        const raycaster = new THREE.Raycaster();
        const mouseVector = new THREE.Vector2();
        let mouseX = 0;
        let mouseY = 0;
        
        const updateCustomCursor = (x, y) => {
            customCursor.style.left = `${x}px`;
            customCursor.style.top = `${y}px`;
        };

        function onMouseMove(event) {
            updateCustomCursor(event.clientX, event.clientY);
            
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            mouseVector.x = mouseX;
            mouseVector.y = mouseY;
            raycaster.setFromCamera(mouseVector, camera);
            
            const intersects = raycaster.intersectObjects(imageMeshes, true);
            const newIsOverClickable = intersects.length > 0;
            
            if (newIsOverClickable) {
                let targetMesh = intersects[0].object;
                
                while (targetMesh && !imageUrlsMap.has(targetMesh)) {
                    targetMesh = targetMesh.parent;
                }

                if (targetMesh && hoveredMesh !== targetMesh) {
                    if (hoveredMesh && hoveredMesh.userData.glow) {
                        hoveredMesh.userData.glow.visible = false;
                    }
                    hoveredMesh = targetMesh;
                    if (hoveredMesh && hoveredMesh.userData.glow) {
                        hoveredMesh.userData.glow.visible = true;
                    }
                }
            } else {
                if (hoveredMesh) {
                    if (hoveredMesh.userData.glow) {
                        hoveredMesh.userData.glow.visible = false;
                    }
                    hoveredMesh = null;
                }
            }

            if (newIsOverClickable !== isOverClickable) {
                isOverClickable = newIsOverClickable;
                if (isOverClickable) {
                    customCursor.style.transform = 'translate(-50%, -50%) scale(1.5)';
                } else {
                    customCursor.style.transform = 'translate(-50%, -50%) scale(1)';
                }
            }
        }

        function onMouseClick(event) {
            mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObjects(imageMeshes, true);

            if (intersects.length > 0) {
                let intersectedObject = intersects[0].object;
                
                let targetUrl = imageUrlsMap.get(intersectedObject);
                if (!targetUrl && intersectedObject.parent) {
                    let parent = intersectedObject.parent;
                    while(parent) {
                        if(imageUrlsMap.has(parent)) {
                            targetUrl = imageUrlsMap.get(parent);
                            break;
                        }
                        parent = parent.parent;
                    }
                }

                if (targetUrl) {
                    console.log(`í˜ì´ì§€ ì´ë™: ${targetUrl}`);
                    // ğŸ’¡ [ìˆ˜ì •] ì§ì ‘ ì´ë™ ëŒ€ì‹  ë¶€ë“œëŸ¬ìš´ ì „í™˜ í•¨ìˆ˜ í˜¸ì¶œ
                    smoothNavigate(targetUrl);
                }
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        
        window.addEventListener('touchmove', (event) => {
            if (event.touches.length > 0) {
                updateCustomCursor(event.touches[0].clientX, event.touches[0].clientY);
            }
            onMouseMove({ 
                clientX: event.touches[0].clientX, 
                clientY: event.touches[0].clientY 
            });
        }, { passive: true });


        // --- 6. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ---
        function animate() {
            requestAnimationFrame(animate);

            if (animationProgress < animationDuration) {
                animationProgress++;
                const ratio = animationProgress / animationDuration; 
                const easedRatio = 1 - Math.pow(1 - ratio, 3); 
                
                imageMeshes.forEach((mesh, index) => {
                    const startPosition = new THREE.Vector3(0, 0, -5); 
                    const targetPosition = targetPositions[index]; 

                    mesh.position.lerpVectors(startPosition, targetPosition, easedRatio);
                    mesh.scale.setScalar(easedRatio);
                    mesh.lookAt(0, 0, 0); 
                });
            }

            const targetCameraRotY = -mouseX * (Math.PI / 4); 
            const targetCameraRotX = mouseY * (Math.PI / 6); 

            yawObject.rotation.y += (targetCameraRotY - yawObject.rotation.y) * 0.05;
            camera.rotation.x += (targetCameraRotX - camera.rotation.x) * 0.05;

            if (controller) {
                const targetLogoRotY = mouseX * 0.5; 
                const targetLogoRotX = -mouseY * 0.5;

                controller.rotation.y += (targetLogoRotY - controller.rotation.y) * 0.1;
                controller.rotation.x += (targetLogoRotX - controller.rotation.x) * 0.1;

                controller.visible = false;
                cubeCamera.position.copy(yawObject.position);
                cubeCamera.rotation.copy(yawObject.rotation); 
                cubeCamera.update(renderer, scene); 
                controller.visible = true;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // --- 8. ë©”ë‰´ ë°” ë¡œì§ ---
        const hamburgerIcon = document.getElementById('hamburgerIcon');
        const menuContainer = document.getElementById('menuContainer');
        const menuClose = document.getElementById('menuClose');
        
        function toggleMenu() {
            const isExpanded = menuContainer.classList.toggle('expanded');
            
            if (isExpanded) {
                 menuClose.style.opacity = '1';
                 menuClose.style.pointerEvents = 'auto';
                 hamburgerIcon.style.opacity = '0';
                 hamburgerIcon.style.pointerEvents = 'none';
            } else {
                 menuClose.style.opacity = '0';
                 menuClose.style.pointerEvents = 'none';
                 hamburgerIcon.style.opacity = '1';
                 hamburgerIcon.style.pointerEvents = 'auto';
            }
        }

        hamburgerIcon.addEventListener('click', toggleMenu);
        menuClose.addEventListener('click', toggleMenu);

        // ğŸ’¡ [ì¶”ê°€] ë©”ë‰´ ë§í¬ í´ë¦­ ì‹œì—ë„ ë¶€ë“œëŸ¬ìš´ ì „í™˜ ì ìš©
        const menuLinks = document.querySelectorAll('.menu-link');
        menuLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault(); // ê¸°ë³¸ ì´ë™ ë§‰ê¸°
                const targetUrl = link.getAttribute('href');
                smoothNavigate(targetUrl); // ë¶€ë“œëŸ¬ìš´ ì´ë™ í•¨ìˆ˜ í˜¸ì¶œ
            });
        });

    </script>
</body>
</html>